{
    "contents" : "# Server file for Shiny App\n# Be careful to update the directories\n\nrm(list = ls())  # clean out workspace and set working directory\n\nsetwd('C:/Users/flbk/Documents/GitHub/FlomKart')\n\nlibrary(shiny)        # TO run the app!\nlibrary(leaflet)      # For the interactive map    \nlibrary(RNetCDF)      # To read the data in netCDF files\nlibrary(magrittr)     # For piping functions\nlibrary(evd)          # Functions for extreme value distributions\nlibrary(nsRFA)       # For the GL distrib (,aybe pearson too)\nlibrary(formattable)  # To add formatting to data tables\nlibrary(DT)         # for the data tables\nlibrary(shinyBS)      # for the interactive popover features\n\n\nnc <- open.nc(\"output/flood_database.nc\", write = FALSE)  # Put FALSE for read-only\ngof_nc <- open.nc(\"output/gof.nc\", write = FALSE)  # Put FALSE for read-only\n\n# Compare with gof_noXvalid.nc\n# gof_nc <- open.nc(\"output/gof_noXvalid.nc\", write = FALSE)  # Put FALSE for read-only\n\n\nQ <- var.get.nc(nc, \"Q\")\ndistr.name <- var.get.nc(nc, \"distr.name\")\nmethod.name <- var.get.nc(nc, \"method.name\")\nreturn.periods <- var.get.nc(gof_nc, \"r.periods\")\n\n# For the map\nstation <- list()\nstation$name <- var.get.nc(nc, \"station.name\")\nstation$number <- var.get.nc(nc, \"station.number\")\nstation$nve_nb <- var.get.nc(nc, \"station.nve_nb\")\nstation$utmN <- var.get.nc(nc, \"station.utmN\")\nstation$utmE <- var.get.nc(nc, \"station.utmE\")\nstation$long <- var.get.nc(nc, \"station.long\")\nstation$lat <- var.get.nc(nc, \"station.lat\")\nstation$catchment.size <- var.get.nc(nc, \"catchment.size\")\nstation$catchment.min.height <- var.get.nc(nc, \"catchment.min.height\")\nstation$catchment.max.height <- var.get.nc(nc, \"catchment.max.height\")\n\ndim.random_runs <- var.get.nc(nc, \"dim.random_runs\")\nsampling_years <<- var.get.nc(nc, \"sampling_years\")\nsampling_years_full_record <- c(as.character(sampling_years), NA, NA, NA, NA, NA, NA, \"FULL RECORD\")\n\nrperiods.bs <- c(2,5,10,15,20,30)\nstation$length_rec <- as.vector(rep(NA,length(station$number)))\n\n# station$length_rec <- sapply(na.omit(Q), length)\n\n\nfor (st in seq(along = station$number)) {\n  station$length_rec[st] <- length(as.vector(na.omit(Q[st, ])))\n  \n}\n\nkeep <- which(!is.na(station$lat + station$long))\n## Lets keep only the stations that have more than 30 years of data\nkeep <- intersect(keep, which(station$length_rec > 29))\n\nstation$index <- keep\nstation$length_rec <- station$length_rec[keep]\nstation$name <- station$name[keep]\nstation$number <- station$number[keep]\nstation$nve_nb <- station$nve_nb[keep]\nstation$long <- station$long[keep]\nstation$lat <- station$lat[keep]\nstation$utmN <- station$utmN[keep]\nstation$utmE <- station$utmE[keep]\nstation$catchment.size <- station$catchment.size[keep]\nstation$catchment.min.height <- station$catchment.min.height[keep]\nstation$catchment.max.height <- station$catchment.max.height[keep]\n\n# adding the shape param for gev (it is the 3rd parameter)\ngev.shape.estimate <- var.get.nc(nc, \"param.estimate\", \n                                 start = c(1, 3, 1, 3, 30, 1), # from each station, distr number 3, \n                                 # method number 1 to 4, parameter number 3, full length o record, random run number 1 \n                                 count = c(length(station$name), 1, 4, 1, 1, 1) ) \n\n\n\n# Create here the data frame that will be use in DT tables in the code\nstations.summary.df <- data.frame(\"Station name\" = station$name, \n                                  \"NVE number\" = station$nve_nb,\n                                  \"Length of record\" = station$length_rec,\n                                  \"Shape param GEV_Lmom\" = gev.shape.estimate[ , 2],\n                                  \"Catchment area\" = station$catchment.size,\n                                  \"Min elevation\" = station$catchment.min.height,\n                                  \"Max elevation\" = station$catchment.max.height\n)\n\n\nsource('R/global.R')  # supporting functions for the app\nsource('R/ui.R')  # User inferface function\nshinyApp(ui, server)  # to run the app\n\n\nserver <- function(session,input, output) {\n  \n  # To be able to select stations directly on the map (for the first tab) \n  observeEvent(input$map_marker_click, { # update the map markers and view on map clicks\n    p <- input$map_marker_click\n    leafletProxy(\"map\")\n    \n    updateSelectInput(session, inputId='station', selected =  p$id, \n                      label = \"Pick a station\", choices = station$number)\n  })\n  \n  # This conditional use of \"observe\" updates the random runs selection when the \"FULL RECORD\" is selected\n  observe({\n    if(input$length == \"FULL RECORD\") { \n      output$random.panel <- renderUI({ selectInput(inputId='random', selected =  1, \n                                                    label = \"There are no subsamples\", choices = 1)\n      })  \n      #       cat(file=\"output/app_output.txt\", \"full record has been selected for station\", input$station, \"\\n\") # test of debugging functionality \n      \n    } else {\n      output$random.panel <- renderUI({ sliderInput(\"random\", \n                                                    \"Browse the random runs\", \n                                                    value = 25,\n                                                    min = 1, \n                                                    max = 50)\n      })\n    } \n  }) \n  \n  ## Below are reactive variables based on inputs selected in the UI ------------------\n  \n  old_station.index <- reactive({ station$index[which(station$number == input$station)]  \n    # station$index is called in order to go back\n    # to the original indexes of the nc file\n  })\n  new_station.index  <- reactive({ which(station$number == input$station)  \n  })\n  \n  distr.index <- reactive({ which(distr.name == input$distr)\n  })\n  method.index <- reactive({ which(method.name == input$method)\n  })\n  random.index <- reactive({ as.numeric(input$random)\n  })\n  length.index <- reactive({ which(sampling_years_full_record == input$length)\n  })\n  distr2plot <- reactive({ which(distr.name == input$distr2plot)\n  })\n  method2plot <- reactive({ which(method.name == input$method2plot)\n  })\n  param.estimate <- reactive({ var.get.nc(nc, \"param.estimate\", \n                                          start = c(old_station.index(), distr.index(), method.index(), 1, length.index(), random.index()), \n                                          count = c(1, 1, 1, 3, 1, 1)) \n  }) \n  \n  ## Rendering of the goodness of fit plots for the related GOF tabs -------------------\n  \n  output$plot.ks <- renderPlot({\n    plot4server_gof(old_station.index(), \"KS\")\n  })\n  \n  output$plot.ad <- renderPlot({\n    plot4server_gof(old_station.index(), \"AD\")\n  })\n  output$plot.cs <- renderPlot({\n    plot4server_gof(old_station.index(), \"CS\")\n  })\n  output$plot.rlevels <- renderPlot({\n    plot4server_gof.rlevels(old_station.index(), \"r.levels\", input$r.period)\n  })\n  output$plot.qs <- renderPlot({\n    plot4server_gof.rlevels(old_station.index(), \"QS\", input$r.period4qs)\n  })\n  output$plot.bs <- renderPlot({\n    plot4server_gof.rlevels(old_station.index(), \"BS\", input$r.period4bs)\n  })\n  output$plot.nt <- renderPlot({\n    plot4server_nt(old_station.index(), \"NT\", input$r.period4nt)\n  })\n  \n  output$plot.rlevels_coeff <- renderPlot({\n    plot4server_rlevels_coeffvar(old_station.index(), input$coeffvar2plot, input$r.period4coefvar)\n  })\n  output$plot.gof_averaged <- renderPlot({\n    plot4server_gof_averaged(input$gof4ave, input$min_years4ave, input$max_years4ave)\n  })\n  output$plot.rlevels_coeff_averaged <- renderPlot({\n    plot4server_rlevels_coeffvar_ave(input$coeffvar2plot_ave, input$r.period4coefvar_ave, input$min_years4coeff_ave, input$max_years4coeff_ave)\n  })\n  \n  \n  ## Main plots for the first tab ---------------  \n  \n  output$main.plot <- renderPlot({\n    plot4server(na.omit(Q[old_station.index(), ]), \n                param.estimate(),\n                distr = distr.index())\n  })\n  output$rlevels.plot <- renderPlot({\n    plot4server_rlevel(na.omit(Q[old_station.index(), ]), \n                       param.estimate(),\n                       distr = distr.index())\n  })\n  output$cdf.plot <- renderPlot({\n    plot4server_cdf(na.omit(Q[old_station.index(), ]), \n                    param.estimate(),\n                    distr = distr.index())\n  })\n  output$qq.plot <- renderPlot({\n    plot4server_qq(na.omit(Q[old_station.index(), ]), \n                   param.estimate(),\n                   distr = distr.index()) \n  })\n  output$map <- renderLeaflet({\n    norway_map4server(input$station)\n  })\n  \n  # Formattable tables, early experiments, the 2 visualizations could be switched with a button\n  output$gof.table <- renderFormattable({ \n    \n    temp.list <- gof_summary(input$gof2table, old_station.index())\n    print(temp.list$max_gof)\n    print(temp.list$min_gof)\n    \n    formattable(temp.list$gof_table, list(\n      # Strangely, the condition didn't work with x == temp.list...\n      gum = formatter(\"span\", style = x ~ ifelse(abs(x - temp.list$min_gof) < 0.00001, style(color = \"green\", font.weight = \"bold\"),\n                                                 ifelse(abs(x - temp.list$max_gof) < 0.00001, style(color = \"red\", font.weight = \"bold\"), NA))),\n      \n      gam = formatter(\"span\", style = x ~ ifelse(abs(x - temp.list$min_gof) < 0.00001, style(color = \"green\", font.weight = \"bold\"),\n                                                 ifelse(abs(x - temp.list$max_gof) < 0.00001, style(color = \"red\", font.weight = \"bold\"), NA))),\n      \n      gev = formatter(\"span\", style = x ~ ifelse(abs(x - temp.list$min_gof) < 0.00001, style(color = \"green\", font.weight = \"bold\"),\n                                                 ifelse(abs(x - temp.list$max_gof) < 0.00001, style(color = \"red\", font.weight = \"bold\"), NA))),\n      \n      glo = formatter(\"span\", style = x ~ ifelse(abs(x - temp.list$min_gof) < 0.00001, style(color = \"green\", font.weight = \"bold\"),\n                                                 ifelse(abs(x - temp.list$max_gof) < 0.00001, style(color = \"red\", font.weight = \"bold\"), NA))),\n      \n      pe3 = formatter(\"span\", style = x ~ ifelse(abs(x - temp.list$min_gof) < 0.00001, style(color = \"green\", font.weight = \"bold\"),\n                                                 ifelse(abs(x - temp.list$max_gof) < 0.00001, style(color = \"red\", font.weight = \"bold\"), NA)))\n    ))\n    \n  })\n  \n  output$gof.table2 <- renderFormattable({ \n    # This is probably not the most helpful way to format this table.\n    formattable(gof_summary_rperiods(input$gof2table2, old_station.index(), input$r.period4table), list(\n      gum = color_tile(\"white\", \"pink\"),\n      gam = color_tile(\"white\", \"pink\"),\n      gev = color_tile(\"white\", \"pink\"),\n      glo = color_tile(\"white\", \"pink\"),\n      pe3 = color_tile(\"white\", \"pink\")\n    ))\n  })\n  \n  # Output DT tables to have some excel feature tables at the end of the app\n  output$test.table <- DT::renderDataTable({\n    datatable(stations.summary.df,\n              # extensions = 'Scroller', \n              filter = 'top', \n              options = list(\n                # dom = 'Bfrtip', buttons = c('copy', 'csv', 'excel', 'pdf', 'print'), # this was for extensions = 'Buttons' which didn't work\n                \n                #               deferRender = TRUE,\n                #               scrollY = 200,\n                #               scroller = TRUE,  \n                \n                pageLength = 20, autoWidth = TRUE, \n                \n                order = list(list(2, 'asc'))\n              )\n              \n              \n    )  \n    #     %>% formatStyle(\n    #     'Station.name',\n    #      backgroundColor = styleInterval(3.4, c('white', 'grey'))\n    #    )  # Can be used for additional styling\n  })\n  \n  ## EXPERIMENTAL : trying to link selected rows to stations in the map DOESNT WORK WITH THIS VERSION OF DT\n  # and the dev version of DT did not work on my computer\n  #   output$map4table <- renderLeaflet({\n  #     norway_map4server(input$test.table_rows_selected)\n  #   })\n  \n  # Computing a reactive group of stations based on best gof performance\n  st_group.indexes <- reactive({ station_group_indexes(input$gof4st_groups, input$distr4st_groups, input$method4st_groups, input$minmax)\n  })\n  \n  # Mapping the groups of stations that have same best method and distr\n  output$map.groups_from_gof <- renderLeaflet({\n    norway_map4groups(st_group.indexes())\n    \n  })\n  \n  # Table for the mapped stations\n  output$group.table <- DT::renderDataTable({\n    datatable(group.dfmaker(st_group.indexes()),\n              # extensions = 'Scroller', \n              filter = 'top', \n              options = list(\n                pageLength = 20, autoWidth = TRUE, \n                order = list(list(2, 'asc'))\n              )\n    )\n  })\n  \n}  # end of server function\n\n# good debuggin tool that stops the browser and lets explore which call cause an error\n# options(shiny.error = browser)\n\n\n## Run the app!  ---------------\nshinyApp(ui, server)\n\n\n\n\n\n\n\n\n\n\n\n##################\n\n# example use of formattable\n# df <- data.frame(\n#   id = 1:10,\n#   name = c(\"Bob\", \"Ashley\", \"James\", \"David\", \"Jenny\", \n#            \"Hans\", \"Leo\", \"John\", \"Emily\", \"Lee\"), \n#   age = c(28, 27, 30, 28, 29, 29, 27, 27, 31, 30),\n#   grade = c(\"C\", \"A\", \"A\", \"C\", \"B\", \"B\", \"B\", \"A\", \"C\", \"C\"),\n#   test1_score = c(8.9, 9.5, 9.6, 8.9, 9.1, 9.3, 9.3, 9.9, 8.5, 8.6),\n#   test2_score = c(9.1, 9.1, 9.2, 9.1, 8.9, 8.5, 9.2, 9.3, 9.1, 8.8),\n#   final_score = c(9, 9.3, 9.4, 9, 9, 8.9, 9.25, 9.6, 8.8, 8.7),\n#   registered = c(TRUE, FALSE, TRUE, FALSE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE),\n#   stringsAsFactors = FALSE)\n# \n# \n# formattable(df, list(\n#   age = color_tile(\"white\", \"orange\"),\n#   grade = formatter(\"span\",\n#                     style = x ~ ifelse(x == \"A\", style(color = \"green\", font.weight = \"bold\"), NA)),\n#   final_score = formatter(\"span\",\n#                           style = x ~ style(color = ifelse(rank(-x) <= 3, \"green\", \"gray\")),\n#                           x ~ sprintf(\"%.2f (rank: %02d)\", x, rank(-x))),\n#   registered = formatter(\"span\", \n#                          style = x ~ style(color = ifelse(x, \"green\", \"red\")))\n# )\n# )\n\n\n# I tried to install the development version of DT for the Buttons feature, but it didn't work. maybe for later\n# install.packages('devtools')\n# devtools::install_github('rstudio/DT')\n\n# example use of DT with highlighting. Looks like a nice way to highlight cells\nlibrary('shinydashboard')\nheader <- dashboardHeader()\n\nsidebar <- dashboardSidebar()\n\nbody <- dashboardBody(\n  DT::dataTableOutput(\"mtcarsTable\")\n)\n\nshinyApp(\n  ui = dashboardPage(header, sidebar, body),\n  server = function(input, output) {\n    \n    output$mtcarsTable <- renderDataTable({\n      DT::datatable(datasets::mtcars, \n                    options = list(rowCallback = JS('\n            function(nRow, aData, iDisplayIndex, iDisplayIndexFull) {\n                                      // Bold and green cells for conditions\n                                      if (parseFloat(aData[3]) >= 200)\n                                      $(\"td:eq(3)\", nRow).css(\"font-weight\", \"bold\");\n                                      if (parseFloat(aData[3]) >= 100)\n                                      $(\"td:eq(3)\", nRow).css(\"background-color\", \"#9BF59B\");\n                                       }')\n                    )\n      )\n    })\n  }\n)\n\n# shinyjs is installed, it could be interesting\n\n# sparkline to check, could be good complement of DT tables \n# library(devtools)\n# install_github('htmlwidgets/sparkline')\n",
    "created" : 1463041329294.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "726973812",
    "id" : "4B5271B2",
    "lastKnownWriteTime" : 1462878772,
    "path" : "~/GitHub/FlomKart_ShinyApp/R/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}